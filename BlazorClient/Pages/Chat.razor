@page "/chat/{ChatRoomId:int}"
@attribute [Authorize]
@using BlazorClient.Shared
@using System.Net.Http.Json
@using System.Linq
@implements IAsyncDisposable
@inject HttpClient Http
@inject BlazorClient.Services.ChatClientService ChatService
@inject TokenStorageService TokenStorage
@inject NavigationManager Navigation
@inject BlazorClient.Services.ToastService ToastService
@inject BlazorClient.Services.FriendApiService FriendService
@inject Microsoft.JSInterop.IJSRuntime JSRuntime
@using Microsoft.JSInterop

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 1200px;
        margin: 0 auto;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .chat-header {
        background: rgba(255, 255, 255, 0.95);
        padding: 1.5rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-bottom: 1px solid #e0e0e0;
    }

    .chat-header h2 {
        margin: 0;
        color: #333;
        font-size: 1.5rem;
        font-weight: 600;
    }

    .chat-header .chat-id {
        color: #666;
        font-size: 0.9rem;
        margin-top: 0.25rem;
    }

    .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        scroll-behavior: smooth;
    }

    .messages-container::-webkit-scrollbar {
        width: 8px;
    }

    .messages-container::-webkit-scrollbar-track {
        background: #f1f1f1;
    }

    .messages-container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    .message {
        display: flex;
        margin-bottom: 0.5rem;
        animation: fadeIn 0.3s ease-in;
    }

    @@keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .message.own {
        justify-content: flex-end;
    }

    .message.other {
        justify-content: flex-start;
    }

    .message-bubble {
        max-width: 70%;
        padding: 0.75rem 1rem;
        border-radius: 1.25rem;
        word-wrap: break-word;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .message.own .message-bubble {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 0.25rem;
    }

    .message.other .message-bubble {
        background: white;
        color: #333;
        border-bottom-left-radius: 0.25rem;
    }

    .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.25rem;
    }

    .message-sender {
        font-weight: 600;
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
    }

    .message.own .message-sender {
        color: rgba(255, 255, 255, 0.9);
    }

    .message.other .message-sender {
        color: #667eea;
    }

    .message-text {
        font-size: 0.95rem;
        line-height: 1.4;
    }

    .message-text.deleted {
        font-style: italic;
        color: #6c757d;
    }

    .edited-label {
        font-size: 0.75rem;
        margin-left: 0.5rem;
        opacity: 0.8;
    }

    .message-time {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-top: 0.25rem;
        text-align: right;
    }

    .input-container {
        background: white;
        padding: 1.5rem;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        border-top: 1px solid #e0e0e0;
        position: relative;
        z-index: 10;
    }

    .input-wrapper {
        display: flex;
        gap: 0.75rem;
        align-items: center;
    }

    .message-input {
        flex: 1;
        padding: 0.875rem 1.25rem;
        border: 2px solid #e0e0e0;
        border-radius: 2rem;
        font-size: 1rem;
        outline: none;
        transition: all 0.3s ease;
        background: white;
        color: #333;
        pointer-events: auto;
        z-index: 1;
    }

    .message-input:focus {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .send-button {
        padding: 0.875rem 2rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 2rem;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .send-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }

    .send-button:active:not(:disabled) {
        transform: translateY(0);
    }

    .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .message-actions {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
    }

    .message-actions button {
        background: transparent;
        border: none;
        color: #ffffffcc;
        cursor: pointer;
        font-size: 0.8rem;
        padding: 0.25rem 0.5rem;
        border-radius: 0.5rem;
        transition: background 0.2s ease;
    }

    .message.other .message-actions button {
        color: #667eea;
    }

    .message-actions button:hover {
        background: rgba(255, 255, 255, 0.15);
    }

    .message-actions .danger {
        color: #ff6b6b;
    }

    .search-bar {
        margin-top: 1rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    .search-bar input {
        flex: 1;
        min-width: 200px;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #ccc;
    }

    .search-bar button {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        border: none;
        background: #667eea;
        color: white;
        cursor: pointer;
    }

    .search-bar button.secondary {
        background: #e0e0e0;
        color: #333;
    }

    .search-results {
        background: white;
        margin: 1rem;
        padding: 1rem;
        border-radius: 1rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        max-height: 200px;
        overflow-y: auto;
    }

    .search-results li {
        transition: background-color 0.2s ease;
    }

    .search-results li:hover {
        background-color: #f0f0f0;
    }

    .editing-banner {
        background: #fff3cd;
        border: 1px solid #ffecb5;
        color: #856404;
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
        margin-bottom: 0.75rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .editing-banner button {
        border: none;
        background: transparent;
        color: #856404;
        cursor: pointer;
        font-weight: 600;
    }

    .empty-state {
        text-align: center;
        color: #999;
        padding: 3rem;
        font-style: italic;
    }

    .connection-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 0.5rem;
    }

    .connection-status.connected {
        background: #4caf50;
        box-shadow: 0 0 8px #4caf50;
    }

    .connection-status.disconnected {
        background: #f44336;
        box-shadow: 0 0 8px #f44336;
    }

    .invite-button {
        margin-top: 0.75rem;
        padding: 0.4rem 0.9rem;
        font-size: 0.85rem;
        border-radius: 999px;
        border: 1px solid #667eea;
        background: white;
        color: #667eea;
        cursor: pointer;
    }

    .invite-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .invite-modal {
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        max-width: 450px;
        width: 90%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .invite-modal h3 {
        margin-top: 0;
        margin-bottom: 0.75rem;
    }

    .invite-list {
        max-height: 220px;
        overflow-y: auto;
        margin-top: 0.5rem;
        margin-bottom: 1rem;
    }

    .invite-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
    }
</style>

<div class="chat-container">
    <div class="chat-header">
        <h2>
            <span class="connection-status @(isConnected ? "connected" : "disconnected")"></span>
            Chat Room
        </h2>
        <div class="chat-id">Room ID: @ChatRoomId</div>
        <div class="search-bar">
            <input @bind="searchQuery" placeholder="Search messages..." @bind:event="oninput" />
            <button @onclick="SearchMessagesAsync">Search</button>
            <button class="secondary" @onclick="ClearSearch" disabled="@(!searchPerformed)">Clear</button>
        </div>
        @if (isGroupChat)
        {
            <button class="invite-button" type="button" @onclick="OpenInviteModal">
                Invite friends to this group
            </button>
        }
    </div>

    @if (searchPerformed)
    {
        <div class="search-results">
            <strong>@(searchResults.Count) result(s)</strong>
            @if (searchResults.Count == 0)
            {
                <p>No messages matched "@searchQuery".</p>
            }
            else
            {
                <ul>
                    @foreach (var result in searchResults)
                    {
                        <li style="cursor: pointer; padding: 0.5rem; border-radius: 4px;"
                            @onclick="() => JumpToMessage(result.Id)">
                            <span>@result.SentAtUtc.ToLocalTime(): @(
                                    result.IsDeleted ? "[deleted]" : result.Text.Length > 60 ? result.Text[..60] + "..." : result.Text
                                )</span>
                        </li>
                    }
                </ul>
            }
        </div>
    }

    <div class="messages-container" @ref="messagesContainer">
        @if (messages.Count == 0)
        {
            <div class="empty-state">
                <p>No messages yet. Start the conversation!</p>
            </div>
        }
        else
        {
            @foreach (var m in messages)
            {
                var isOwnMessage = m.SenderId == currentUserId;
                <div class="message @(isOwnMessage ? "own" : "other")" id="message-@m.Id">
                    <div class="message-bubble">
                        @if (!isOwnMessage)
                        {
                            <div class="message-sender">@GetShortSenderId(m.SenderId)</div>
                        }
                        @if (m.IsDeleted)
                        {
                            <div class="message-text deleted">This message was deleted.</div>
                        }
                        else
                        {
                            <div class="message-text">@m.Text</div>
                            @if (m.IsEdited)
                            {
                                <span class="edited-label">(edited)</span>
                            }
                        }
                        <div class="message-time">@m.SentAtUtc.ToLocalTime().ToString("HH:mm")</div>
                        @if (isOwnMessage && !m.IsDeleted)
                        {
                            <div class="message-actions">
                                <button @onclick="() => BeginEdit(m)">Edit</button>
                                <button class="danger" @onclick="() => DeleteMessageAsync(m.Id)">Delete</button>
                            </div>
                        }
                    </div>
                </div>
            }
    }
</div>

    <div class="input-container">
        @if (isEditing)
        {
            <div class="editing-banner">
                <span>Editing your message</span>
                <button @onclick="CancelEdit">Cancel</button>
            </div>
        }
        <div class="input-wrapper">
            <input
                class="message-input"
                @bind="currentText"
                @bind:event="oninput"
                @onkeydown="HandleKeyDown"
                @onkeyup="HandleKeyUp"
                placeholder="@(isEditing ? "Update your message..." : "Type your message...")"
                autocomplete="off"
                id="message-input-field" />
            <button
                class="send-button"
                @onclick="SendAsync"
                disabled="@(string.IsNullOrWhiteSpace(currentText))"
                type="button"
                id="send-message-button">
                Send
            </button>
        </div>
        <div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
            <span>
                @if (!string.IsNullOrWhiteSpace(currentText))
                {
                    <text>Ready to send (@currentText.Length characters) - Text: "@currentText"</text>
                }
                else
                {
                    <text>Type a message to send...</text>
                }
            </span>
            <button
                type="button"
                style="padding: 0.25rem 0.5rem; font-size: 0.7rem; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; margin-left: 0.5rem;"
                @onclick="TestInput">
                Test Input
            </button>
            <button
                type="button"
                style="padding: 0.25rem 0.5rem; font-size: 0.7rem; background: #4caf50; color: white; border: 1px solid #4caf50; border-radius: 4px; cursor: pointer; margin-left: 0.5rem;"
                @onclick="ForceSendTest">
                Force Send Test
            </button>
        </div>
    </div>
</div>

@if (showInviteModal && isGroupChat)
{
    <div class="invite-modal-overlay" @onclick="CloseInviteModal">
        <div class="invite-modal" @onclick:stopPropagation="true">
            <h3>Invite friends to this group</h3>
            @if (isLoadingInviteData)
            {
                <p>Loading friends...</p>
            }
            else if (availableFriendsToInvite.Count == 0)
            {
                <p>You have no friends to invite. Add friends first from the Friends page.</p>
            }
            else
            {
                <p>Select one or more friends to add to this group chat.</p>
                <div class="invite-list">
                    @foreach (var friend in availableFriendsToInvite)
                    {
                        <div style="padding: 0.5rem 0;">
                            <input type="checkbox"
                                   id="friend-@friend.UserId"
                                   checked="@selectedInviteFriendIds.Contains(friend.UserId)"
                                   @onchange="@((ChangeEventArgs e) => {
                                       if (e.Value is bool isChecked)
                                       {
                                           if (isChecked && !selectedInviteFriendIds.Contains(friend.UserId))
                                               selectedInviteFriendIds.Add(friend.UserId);
                                           else if (!isChecked)
                                               selectedInviteFriendIds.Remove(friend.UserId);
                                       }
                                   })" />
                            <label for="friend-@friend.UserId" style="margin-left: 0.5rem; cursor: pointer;">@friend.Username</label>
                        </div>
                    }
                </div>
            }
            <div class="invite-actions">
                <button type="button" class="secondary" @onclick="CloseInviteModal">Cancel</button>
                <button type="button" @onclick="InviteSelectedFriends" disabled="@(isLoadingInviteData || selectedInviteFriendIds.Count == 0)">
                    Add to group
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public int ChatRoomId { get; set; }

    private List<MessageDto> messages = new();
    private string currentText = "";
    private int currentUserId;
    private bool isConnected = false;
    private ElementReference messagesContainer;
    private bool isEditing;
    private int editingMessageId;
    private string searchQuery = string.Empty;
    private bool searchPerformed;
    private List<MessageDto> searchResults = new();

    // Whether this room is a group chat (true) or private chat (false)
    private bool isGroupChat;

    // Group chat invitations
    private bool showInviteModal;
    private bool isLoadingInviteData;
    private List<FriendDto> allFriends = new();
    private List<int> selectedInviteFriendIds = new();

    // For now, show all friends (server will reject duplicates or non-members appropriately)
    private List<FriendDto> availableFriendsToInvite => allFriends;

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"OnInitializedAsync: ChatRoomId = {ChatRoomId}");

        ChatService.OnMessageReceived += AddMessage;
        ChatService.OnMessageEdited += HandleMessageEdited;
        ChatService.OnMessageDeleted += HandleMessageDeleted;

        try
        {
            var currentUser = await TokenStorage.GetUserAsync();
            if (currentUser == null)
            {
                Console.WriteLine("OnInitializedAsync: No current user, redirecting to login");
                Navigation.NavigateTo("login");
                return;
            }

            currentUserId = currentUser.Id;
            Console.WriteLine($"OnInitializedAsync: currentUserId = {currentUserId}");

            try
            {
                await ChatService.StartAsync();
                Console.WriteLine($"SignalR connection state: {ChatService.IsConnected}");
            }
            catch (Exception signalrEx)
            {
                Console.WriteLine($"SignalR connection failed: {signalrEx.Message}");
                Console.WriteLine($"Stack trace: {signalrEx.StackTrace}");
                // Continue anyway - we can use HTTP fallback
            }

            try
            {
                await ChatService.JoinChat(ChatRoomId);
                Console.WriteLine($"Joined chat room {ChatRoomId}");
            }
            catch (Exception joinEx)
            {
                Console.WriteLine($"Failed to join chat: {joinEx.Message}");
                // Continue anyway
            }

            isConnected = ChatService.IsConnected;
            Console.WriteLine($"Final connection status: {isConnected}");

            if (!isConnected)
            {
                Console.WriteLine("Warning: SignalR connection not established, will use HTTP fallback");
            }

            StateHasChanged();

            // Detect whether this room is a group chat (for invite button)
            await DetectGroupChatAsync();

            var history = await Http.GetFromJsonAsync<List<MessageDto>>($"api/chatrooms/{ChatRoomId}/messages");
            if (history != null)
            {
                messages = history;
                await ScrollToBottom();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error connecting: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            isConnected = false;
            // Still allow sending messages via HTTP fallback
            StateHasChanged();
        }
    }

    private async Task DetectGroupChatAsync()
    {
        try
        {
            // If this succeeds, it's a group chat. For private chats the API
            // will respond with an error (e.g. "Not a group chat").
            var response = await Http.GetAsync($"api/groupchat/{ChatRoomId}/members");
            isGroupChat = response.IsSuccessStatusCode;
        }
        catch
        {
            // Treat failures as non-group chats; we only use this to toggle UI
            isGroupChat = false;
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task OpenInviteModal()
    {
        showInviteModal = true;
        await LoadInviteData();
    }

    private void CloseInviteModal()
    {
        showInviteModal = false;
        selectedInviteFriendIds.Clear();
    }

    private async Task LoadInviteData()
    {
        isLoadingInviteData = true;
        allFriends = new List<FriendDto>();
        selectedInviteFriendIds.Clear();
        StateHasChanged();

        try
        {
            Console.WriteLine("LoadInviteData: Starting to load friends...");

            // Create a timeout task
            var friendsTask = FriendService.GetFriendsAsync();
            var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5));

            var completedTask = await Task.WhenAny(friendsTask, timeoutTask);

            if (completedTask == timeoutTask)
            {
                // Timeout occurred
                Console.WriteLine("LoadInviteData: Request timed out after 5 seconds");
                ToastService.ShowError("Loading friends timed out. Please check your connection and try again.");
                allFriends = new List<FriendDto>();
            }
            else
            {
                // Friends task completed
                try
                {
                    var friends = await friendsTask;
                    Console.WriteLine($"LoadInviteData: Got {friends?.Count ?? 0} friends");
                    allFriends = friends ?? new List<FriendDto>();
                }
                catch (HttpRequestException httpEx)
                {
                    Console.WriteLine($"LoadInviteData: HTTP error: {httpEx.Message}");
                    ToastService.ShowError($"Failed to load friends: {httpEx.Message}");
                    allFriends = new List<FriendDto>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"LoadInviteData: Exception: {ex.Message}");
                    Console.WriteLine($"LoadInviteData: Stack trace: {ex.StackTrace}");
                    ToastService.ShowError($"Error loading friends: {ex.Message}");
                    allFriends = new List<FriendDto>();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadInviteData: Outer exception: {ex.Message}");
            ToastService.ShowError($"Error loading friends: {ex.Message}");
            allFriends = new List<FriendDto>();
        }
        finally
        {
            isLoadingInviteData = false;
            Console.WriteLine($"LoadInviteData: Finished. Friends count: {allFriends.Count}, isLoading: {isLoadingInviteData}");
            StateHasChanged();
        }
    }

    private async Task InviteSelectedFriends()
    {
        if (selectedInviteFriendIds.Count == 0)
        {
            ToastService.ShowError("Please select at least one friend to invite.");
            return;
        }

        foreach (var friendId in selectedInviteFriendIds)
        {
            try
            {
                var response = await Http.PostAsJsonAsync(
                    $"api/groupchat/{ChatRoomId}/members",
                    new { UserId = friendId });

                if (!response.IsSuccessStatusCode)
                {
                    var error = await response.Content.ReadAsStringAsync();
                    ToastService.ShowError($"Failed to add friend (ID {friendId}): {error}");
                }
            }
            catch (Exception ex)
            {
                ToastService.ShowError($"Error adding friend (ID {friendId}): {ex.Message}");
            }
        }

        ToastService.ShowSuccess("Friends added to the group (if this is a group chat and you have permission).");
        await LoadInviteData();
        CloseInviteModal();
    }

    private void AddMessage(MessageDto m)
    {
        if (m.ChatRoomId != ChatRoomId)
        {
            return;
        }

        var existing = messages.FirstOrDefault(x => x.Id == m.Id);
        if (existing != null)
        {
            ApplyMessageUpdate(existing, m);
        }
        else
        {
            messages.Add(m);
            // Sort messages by timestamp to maintain chronological order
            messages = messages.OrderBy(msg => msg.SentAtUtc).ToList();
        }

        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private void HandleMessageEdited(MessageDto message)
    {
        ApplyMessageUpdate(message);
    }

    private void HandleMessageDeleted(MessageDto message)
    {
        ApplyMessageUpdate(message);
    }

    private async Task SendAsync()
    {
        Console.WriteLine($"SendAsync called. currentText value: '{currentText}'");
        Console.WriteLine($"currentText is null or whitespace: {string.IsNullOrWhiteSpace(currentText)}");

        if (string.IsNullOrWhiteSpace(currentText))
        {
            Console.WriteLine("SendAsync: currentText is empty, showing error");
            ToastService.ShowError("Please enter a message before sending");
            return;
        }

        var textToSend = currentText.Trim();
        if (string.IsNullOrWhiteSpace(textToSend))
        {
            Console.WriteLine("SendAsync: trimmed text is empty, showing error");
            ToastService.ShowError("Message cannot be empty");
            return;
        }

        Console.WriteLine($"SendAsync: Sending message '{textToSend}' to room {ChatRoomId}");

        // Clear input immediately for better UX
        currentText = "";
        StateHasChanged();

        // Small delay to ensure UI updates
        await Task.Delay(50);

        try
        {
            if (isEditing)
            {
                await SubmitEditAsync(textToSend);
            }
            else
            {
                // Send message via HTTP POST
                // The HTTP endpoint will broadcast to all clients via SignalR automatically
                Console.WriteLine($"Sending message via HTTP to room {ChatRoomId}");
                await SendViaHttp(textToSend);
                ToastService.ShowSuccess("Message sent successfully!");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            ToastService.ShowError($"Error sending message: {ex.Message}");
            currentText = textToSend; // Restore text on error
            StateHasChanged();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendAsync();
        }
    }

    private void HandleKeyUp(KeyboardEventArgs e)
    {
        // Force state update on key up to ensure binding works
        StateHasChanged();
    }

    private void TestInput()
    {
        Console.WriteLine($"TestInput called. currentText = '{currentText}'");
        Console.WriteLine($"currentText length: {currentText?.Length ?? 0}");
        ToastService.ShowInfo($"Input test: '{currentText}' (length: {currentText?.Length ?? 0})");

        // Try to set a test value
        currentText = "Test message " + DateTime.Now.Second;
        StateHasChanged();
        Console.WriteLine($"TestInput: Set currentText to '{currentText}'");
    }

    private async Task ForceSendTest()
    {
        Console.WriteLine("ForceSendTest called");
        currentText = "Test message from force send button";
        StateHasChanged();
        await Task.Delay(100);
        await SendAsync();
    }

    private async Task ShowDiagnostics()
    {
        var token = await TokenStorage.GetTokenAsync();
        var diagnostics = $@"DIAGNOSTICS:
ChatRoomId: {ChatRoomId}
Current Text: '{currentText}' (Length: {currentText?.Length ?? 0})
Token Present: {!string.IsNullOrWhiteSpace(token)}
Token Length: {token?.Length ?? 0}
Http BaseAddress: {Http.BaseAddress}
IsConnected (SignalR): {ChatService.IsConnected}
Current User ID: {await GetCurrentUserId()}
";
        Console.WriteLine(diagnostics);
        ToastService.ShowInfo("Diagnostics printed to console (F12)");
    }

    private async Task<int> GetCurrentUserId()
    {
        try
        {
            var token = await TokenStorage.GetTokenAsync();
            if (string.IsNullOrWhiteSpace(token))
                return -1;

            // Decode JWT to get user ID (simple base64 decode of payload)
            var parts = token.Split('.');
            if (parts.Length < 2)
                return -1;

            var payload = parts[1];
            // Add padding if needed
            switch (payload.Length % 4)
            {
                case 2: payload += "=="; break;
                case 3: payload += "="; break;
            }

            var jsonBytes = Convert.FromBase64String(payload);
            var json = System.Text.Encoding.UTF8.GetString(jsonBytes);
            var doc = System.Text.Json.JsonDocument.Parse(json);
            if (doc.RootElement.TryGetProperty("nameid", out var nameId))
            {
                if (int.TryParse(nameId.GetString(), out var userId))
                    return userId;
            }
            return -1;
        }
        catch
        {
            return -1;
        }
    }


    private async Task SendViaHttp(string textToSend)
    {
        try
        {
            Console.WriteLine($"Sending message via HTTP to chatroom {ChatRoomId}: {textToSend}");

            // Validate message before sending
            if (string.IsNullOrWhiteSpace(textToSend))
            {
                ToastService.ShowError("Message cannot be empty");
                currentText = textToSend;
                return;
            }

             // Enforce maximum length
            if (textToSend.Length > 2000)
            {
                ToastService.ShowError("Message is too long (maximum 2000 characters)");
                currentText = textToSend;
                return;
            }

            // Verify ChatRoomId is valid
            if (ChatRoomId <= 0)
            {
                var errorMsg = $"Invalid chat room ID: {ChatRoomId}. Please select a valid chat room.";
                Console.WriteLine($"SendViaHttp error: {errorMsg}");
                ToastService.ShowError(errorMsg);
                throw new Exception(errorMsg);
            }

            // Verify we have a token
            var token = await TokenStorage.GetTokenAsync();
            if (string.IsNullOrWhiteSpace(token))
            {
                var errorMsg = "You are not authenticated. Please log in again.";
                Console.WriteLine($"SendViaHttp error: {errorMsg}");
                ToastService.ShowError(errorMsg);
                Navigation.NavigateTo("login");
                throw new Exception(errorMsg);
            }

            Console.WriteLine($"Making POST request to: api/chatrooms/{ChatRoomId}/messages");
            Console.WriteLine($"Request body: {{ Text: \"{textToSend}\" }}");
            Console.WriteLine($"Token present: {!string.IsNullOrWhiteSpace(token)}");
            Console.WriteLine($"Token length: {token?.Length ?? 0}");
            Console.WriteLine($"ChatRoomId: {ChatRoomId}");
            Console.WriteLine($"Http.BaseAddress: {Http.BaseAddress}");

            var requestBody = new { Text = textToSend };
            var fullUrl = $"api/chatrooms/{ChatRoomId}/messages";
            Console.WriteLine($"Full URL will be: {Http.BaseAddress}{fullUrl}");

            var response = await Http.PostAsJsonAsync(fullUrl, requestBody);

            Console.WriteLine($"HTTP response status: {response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                var newMessage = await response.Content.ReadFromJsonAsync<MessageDto>();
                if (newMessage != null)
                {
                    Console.WriteLine($"Message sent successfully, ID: {newMessage.Id}");
                    // Message will be added via SignalR broadcast, but add it here too for immediate feedback
                    // The SignalR handler will update it if it's already there
                    AddMessage(newMessage);
                    await ScrollToBottom();
                }
                else
                {
                    Console.WriteLine("Warning: Response was successful but message DTO was null");
                    ToastService.ShowError("Message sent but response was invalid");
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"HTTP error: {response.StatusCode} - {errorContent}");

                // Parse error message for better user feedback
                string errorMessage = $"Failed to send message";
                if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
                {
                    errorMessage = "Chat room not found. Please refresh the page.";
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
                {
                    errorMessage = "You are not authorized. Please log in again.";
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
                {
                    errorMessage = "Invalid message. Please check your input.";
                }
                else if (!string.IsNullOrWhiteSpace(errorContent))
                {
                    try
                    {
                        // Try to parse JSON error response
                        var errorObj = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(errorContent);
                        if (errorObj.TryGetProperty("message", out var msgProp))
                        {
                            errorMessage = msgProp.GetString() ?? errorMessage;
                        }
                    }
                    catch
                    {
                        errorMessage = errorContent.Length > 100 ? errorContent.Substring(0, 100) + "..." : errorContent;
                    }
                }

                ToastService.ShowError(errorMessage);
                currentText = textToSend; // Restore text on error
                throw new Exception($"HTTP send failed: {response.StatusCode} - {errorMessage}");
            }
        }
        catch (HttpRequestException httpEx)
        {
            Console.WriteLine($"HTTP request exception: {httpEx.Message}");
            string errorMsg = "Network error. Please check your connection and try again.";
            if (httpEx.Message.Contains("404"))
            {
                errorMsg = "Chat room not found. Please refresh the page.";
            }
            else if (httpEx.Message.Contains("401") || httpEx.Message.Contains("403"))
            {
                errorMsg = "Authentication failed. Please log in again.";
            }
            ToastService.ShowError(errorMsg);
            currentText = textToSend;
            throw;
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine("Request timed out");
            ToastService.ShowError("Request timed out. Please try again.");
            currentText = textToSend;
            throw;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Exception in SendViaHttp: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            ToastService.ShowError($"Error sending message: {ex.Message}");
            currentText = textToSend;
            throw;
        }
    }

    private void BeginEdit(MessageDto message)
    {
        isEditing = true;
        editingMessageId = message.Id;
        currentText = message.Text;
    }

    private void CancelEdit()
    {
        isEditing = false;
        editingMessageId = 0;
        currentText = string.Empty;
    }

    private async Task SubmitEditAsync(string newText)
    {
        try
        {
            var response = await Http.PutAsJsonAsync($"api/chatrooms/{ChatRoomId}/messages/{editingMessageId}",
                new UpdateMessageRequest { Text = newText });

            if (!response.IsSuccessStatusCode)
            {
                var error = await response.Content.ReadAsStringAsync();
                ToastService.ShowError($"Failed to edit message: {error}");
                currentText = newText;
                return;
            }

            var updated = await response.Content.ReadFromJsonAsync<MessageDto>();
            if (updated != null)
            {
                ApplyMessageUpdate(updated);
                ToastService.ShowSuccess("Message edited successfully");
            }

            isEditing = false;
            editingMessageId = 0;
        }
        catch (Exception ex)
        {
            ToastService.ShowError($"Error editing message: {ex.Message}");
            currentText = newText;
        }
    }

    private async Task DeleteMessageAsync(int messageId)
    {
        try
        {
            var response = await Http.DeleteAsync($"api/chatrooms/{ChatRoomId}/messages/{messageId}");
            if (!response.IsSuccessStatusCode)
            {
                var error = await response.Content.ReadAsStringAsync();
                ToastService.ShowError($"Failed to delete message: {error}");
                return;
            }

            var updated = await response.Content.ReadFromJsonAsync<MessageDto>();
            if (updated != null)
            {
                ApplyMessageUpdate(updated);
                ToastService.ShowSuccess("Message deleted successfully");
            }

            if (isEditing && editingMessageId == messageId)
            {
                CancelEdit();
            }
        }
        catch (Exception ex)
        {
            ToastService.ShowError($"Error deleting message: {ex.Message}");
        }
    }

    private async Task SearchMessagesAsync()
    {
        searchPerformed = true;
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            searchResults.Clear();
            return;
        }
        try
        {
            var results = await Http.GetFromJsonAsync<List<MessageDto>>(
                $"api/chatrooms/{ChatRoomId}/messages/search?query={Uri.EscapeDataString(searchQuery)}");
            searchResults = results ?? new List<MessageDto>();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Search failed: {ex.Message}");
            searchResults = new List<MessageDto>();
        }
    }

    private Task ClearSearch()
    {
        searchQuery = string.Empty;
        searchResults.Clear();
        searchPerformed = false;
        return Task.CompletedTask;
    }

    private async Task ScrollToBottom()
    {
        // CSS flexbox with flex-direction: column will naturally show latest messages
        // The messages container will auto-scroll due to overflow-y: auto
        await Task.Delay(50); // Small delay to ensure DOM is updated
    }

    private async Task JumpToMessage(int messageId)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToElement", $"message-{messageId}");
            // Highlight the message briefly
            await JSRuntime.InvokeVoidAsync("highlightElement", $"message-{messageId}");
            ToastService.ShowInfo("Jumped to message");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error jumping to message: {ex.Message}");
        }
    }

    private string GetShortSenderId(int senderId)
    {
        return $"User {senderId}";
    }

    public async ValueTask DisposeAsync()
    {
        ChatService.OnMessageReceived -= AddMessage;
        ChatService.OnMessageEdited -= HandleMessageEdited;
        ChatService.OnMessageDeleted -= HandleMessageDeleted;
        await ChatService.LeaveChat(ChatRoomId);
    }

    private void ApplyMessageUpdate(MessageDto updated)
    {
        var existing = messages.FirstOrDefault(m => m.Id == updated.Id);
        if (existing != null)
        {
            existing.Text = updated.Text;
            existing.IsEdited = updated.IsEdited;
            existing.IsDeleted = updated.IsDeleted;
            existing.SentAtUtc = updated.SentAtUtc;
        }
        else if (updated.ChatRoomId == ChatRoomId)
        {
            messages.Add(updated);
        }

        InvokeAsync(StateHasChanged);
    }

    private void ApplyMessageUpdate(MessageDto target, MessageDto source)
    {
        target.Text = source.Text;
        target.IsEdited = source.IsEdited;
        target.IsDeleted = source.IsDeleted;
        target.SentAtUtc = source.SentAtUtc;
    }
}
